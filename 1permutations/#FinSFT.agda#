{-# OPTIONS --without-K #-}
{-# OPTIONS --allow-unsolved-metas #-}

module FinSFT where
    open import FinTypes
    open import StandardFinTypes
    open import Agda.Builtin.Sigma
    open import Data.Product using (‚àÉ; proj‚ÇÅ; proj‚ÇÇ)
    open import Data.Nat using (‚Ñï ; _<_)
    open import Data.Fin
    open import NatSFT
    open import General
    open import StandardFinTypesOps
    open ‚Ñï
    open import Relation.Binary.PropositionalEquality

    myFinToFin : {T : Type} -> {t : StandardFinType T} -> (Member T) -> Fin (sftToNat t)
    myFinToFin {_} {FinS t} (left x) = suc (myFinToFin x)
    myFinToFin {_} {FinS t} (right *) = zero

    finToMyFin : {n : ‚Ñï} -> (Fin (suc n)) -> ‚àÉ (Œª T -> Prod (StandardFinType T) (Member T))
    finToMyFin {zero} zero = let st = FinS Fin0 in
                             getTypeFromStandardType st , st times right *
    finToMyFin {suc n} (suc k) = let (t , pm) = finToMyFin {n} k
                                     m = p‚ÇÇ pm in
                                 t Type.+ ùüô , ((FinS (p‚ÇÅ pm)) times left m)

    finfin : {T : Type} -> {t : StandardFinType T} -> Fin (sftToNat t) ‚âà (Member T)
    finfin {_} {Fin0} = Equiv (Œª ()) (Œª ()) (Œª ()) (Œª ())
    finfin {_} {FinS t} = Equiv {!!} {!!} {!!} {!!}
                          -- let x = Œª k -> p‚ÇÇ (proj‚ÇÇ (finToMyFin k)) in
                          -- Equiv (Œª _ ‚Üí right *) myFinToFin {!   !} {!   !}
