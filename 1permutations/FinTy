module FinTypesEquiv where
    open import General
    open import FinTypes
    _â‰‹_ : (A : Type) -> (B : Type) -> Set
    A â‰‹ B = _â‰ˆ_ (Member A) (Member B)

    id : {A : Set} -> A -> A
    id x = x

    --- Reflexivity

    Equiv-reflex : {A : Type} -> A â‰‹ A
    Equiv-reflex = Equiv id id idp idp

    --- Symmetry

    Equiv-symmetry : {A B : Type} -> A â‰‹ B -> B â‰‹ A
    Equiv-symmetry (Equiv f g e1 e2) = Equiv g f e2 e1

    --- Composition

    Equiv-composition : {A B C : Type} -> (A â‰‹ B) -> (B â‰‹ C) -> (A â‰‹ C)
    Equiv-composition {A} {B} {C} (Equiv fab fba eab eba) (Equiv fbc fcb ebc ecb) =
        let a-c-a a = ap fba (ebc (fab a))
            c-a-c c = ap fbc (eba (fcb c))
        in  Equiv (fbc âˆ˜ fab)
                  (fba âˆ˜ fcb)
                  (Î» a -> comp (a-c-a a) (eab a))
                  (Î» c -> comp (c-a-c c) (ecb c))

    --- Ã— Unit

    Ã—-embedðŸ™ : {A : Type} -> Member A -> Member (ðŸ™ Ã— A)
    Ã—-embedðŸ™ a = (* , a)

    Ã—-projectðŸ™ : {A : Type} -> Member (ðŸ™ Ã— A) -> Member A
    Ã—-projectðŸ™ (* , a) = a

    Ã—-unit : {A B : Type} -> (ðŸ™ Ã— A) â‰‹ A
    Ã—-unit = Equiv Ã—-projectðŸ™ Ã—-embedðŸ™ (Î» {(* , a) â†’ idp}) idp

    --- Ã— Commutativity

    Ã—-swap : {A B : Type} -> Member (A Ã— B) -> Member (B Ã— A)
    Ã—-swap (a , b) = (b , a)

    lemma-Ã—-swap : {A B : Type} -> (ab : Member (A Ã— B)) -> (Ã—-swap (Ã—-swap ab)) == ab
    lemma-Ã—-swap (a , b) = idp (a , b)

    Ã—-commut : {A B : Type} -> (A Ã— B) â‰‹ (B Ã— A)
    Ã—-commut = Equiv Ã—-swap Ã—-swap lemma-Ã—-swap lemma-Ã—-swap

    --- Ã— Associativity

    r-Ã—assc : {A B C : Type} -> Member (A Ã— (B Ã— C)) -> Member ((A Ã— B) Ã— C)
    r-Ã—assc (a , (b , c)) = ((a , b) , c)

    l-Ã—assc : {A B C : Type} -> Member ((A Ã— B) Ã— C) -> Member (A Ã— (B Ã— C))
    l-Ã—assc ((a , b) , c) = (a , (b , c))

    rl-Ã—assc-lemma : {A B C : Type} -> (a : Member ((A Ã— B) Ã— C)) -> r-Ã—assc (l-Ã—assc a) == a
    rl-Ã—assc-lemma ((a , b) , c) = idp ((a , b) , c)

    lr-Ã—assc-lemma : {A B C : Type} -> (a : Member (A Ã— (B Ã— C))) -> l-Ã—assc (r-Ã—assc a) == a
    lr-Ã—assc-lemma (a , (b , c)) = idp (a , (b , c))

    Ã—-assoc : {A B C : Type} -> (A Ã— (B Ã— C)) â‰‹ ((A Ã— B) Ã— C)
    Ã—-assoc = Equiv r-Ã—assc l-Ã—assc lr-Ã—assc-lemma rl-Ã—assc-lemma

    --- Ã— Unit

    +-embedðŸ˜ : {A : Type} -> Member A -> Member (ðŸ˜ + A)
    +-embedðŸ˜ a = right a

    +-projectðŸ˜ : {A : Type} -> Member (ðŸ˜ + A) -> Member A
    +-projectðŸ˜ (right a) = a

    +-project-embedðŸ˜ : {A : Type} -> (a : Member (ðŸ˜ + A)) -> +-embedðŸ˜ (+-projectðŸ˜ a) == a
    +-project-embedðŸ˜ (right a) = idp (right a)

    +-unit : {A : Type} -> (ðŸ˜ + A) â‰‹ A
    +-unit = Equiv +-projectðŸ˜ +-embedðŸ˜ +-project-embedðŸ˜ idp

    --- ðŸ˜ Ã— A = ðŸ˜

    Ã—ðŸ˜ : {A : Type} -> ðŸ˜ â‰‹ (ðŸ˜ Ã— A)
    Ã—ðŸ˜ = let absurd-eq = (Î» a -> absurdðŸ˜ {Ã—fst (absurdðŸ˜ a) == a} a)
             absurd-proj = (Î» b -> absurdðŸ˜ {absurdðŸ˜ (Ã—fst b) == b} (Ã—fst b))
         in  Equiv absurdðŸ˜ Ã—fst absurd-eq absurd-proj

    --- + Commutativity

    +-swap : {A B : Type} -> Member (A + B) -> Member (B + A)
    +-swap (left x) = right x
    +-swap (right x) = left x

    lemma-+-swap : {A B : Type} -> (ab : Member (A + B)) -> (+-swap (+-swap ab)) == ab
    lemma-+-swap (left x) = idp (left x)
    lemma-+-swap (right x) = idp (right x)

    +-commut : {A B : Type} -> (A + B) â‰‹ (B + A)
    +-commut = Equiv +-swap +-swap lemma-+-swap lemma-+-swap

    --- + Associativity

    r-+assc : {A B C : Type} -> Member (A + (B + C)) -> Member ((A + B) + C)
    r-+assc (left x) = left (left x)
    r-+assc (right (left x)) = left (right x)
    r-+assc (right (right x)) = right x

    l-+assc : {A B C : Type} -> Member ((A + B) + C) -> Member (A + (B + C))
    l-+assc (left (left x)) = left x
    l-+assc (left (right x)) = right (left x)
    l-+assc (right x) = right (right x)

    rl-+assc-lemma : {A B C : Type} -> (a : Member ((A + B) + C)) -> r-+assc (l-+assc a) == a
    rl-+assc-lemma (left (left x)) = idp (left (left x))
    rl-+assc-lemma (left (right x)) = idp (left (right x))
    rl-+assc-lemma (right x) = idp (right x)

    lr-+assc-lemma : {A B C : Type} -> (a : Member (A + (B + C))) -> l-+assc (r-+assc a) == a
    lr-+assc-lemma (left x) = idp (left x)
    lr-+assc-lemma (right (left x)) = idp (right (left x))
    lr-+assc-lemma (right (right x)) = idp (right (right x))

    +-assoc : {A B C : Type} -> (A + (B + C)) â‰‹ ((A + B) + C)
    +-assoc = Equiv r-+assc l-+assc lr-+assc-lemma rl-+assc-lemma

    --- Distrbutivity

    distrib : {A B C : Type} -> Member ((B + C) Ã— A) -> Member ((B Ã— A) + (C Ã— A))
    distrib ((left b) , a) = left (b , a)
    distrib ((right c) , a) = right (c , a)

    unify : {A B C : Type} -> Member ((B Ã— A) + (C Ã— A)) -> Member ((B + C) Ã— A)
    unify (left (b , a)) = ((left b) , a)
    unify (right (b , a)) = ((right b) , a)

    unify-distrib-lemma : {A B C : Type} -> (a : Member ((B Ã— A) + (C Ã— A))) -> distrib (unify a) == a
    unify-distrib-lemma (left (b , a)) = idp (left (b , a))
    unify-distrib-lemma (right (b , a)) = idp (right (b , a))

    distrib-unify-lemma : {A B C : Type} -> (a : Member ((B + C) Ã— A)) -> unify (distrib a) == a
    distrib-unify-lemma ((left b) , a) = idp ((left b) , a)
    distrib-unify-lemma ((right b) , a) = idp ((right b) , a)

    Ã—+-distrib : {A B C : Type} -> ((B + C) Ã— A) â‰‹ ((B Ã— A) + (C Ã— A))
    Ã—+-distrib = Equiv distrib unify distrib-unify-lemma unify-distrib-lemma

    --- Equiv respects +
    Equiv-+respects : {A B C D : Type} -> (A â‰‹ B) -> (C â‰‹ D) -> (A + C) â‰‹ (B + D)
    Equiv-+respects e1 e2 = {!   !}

    Equiv-Ã—respects : {A B C D : Type} -> (A â‰‹ B) -> (C â‰‹ D) -> (A Ã— C) â‰‹ (B Ã— D)
    Equiv-Ã—respects e1 e2 = {!   !}
