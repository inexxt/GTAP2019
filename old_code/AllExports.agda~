module _ where

open import Data.List
open import Data.Nat
open import Data.List.Properties
open import Data.Nat.Properties
open import Data.Product using (Σ; ∃; _×_; _,_; proj₁; proj₂)
open import Data.Fin using (Fin)

open import Relation.Nullary
open import Data.Empty
open import Data.Sum hiding (swap)
open import Data.Bool hiding (_<_; _≤_; _≟_; _<?_; _≤?_)
open import Data.Bool.Properties hiding (≤-reflexive; ≤-trans; _≟_; _<?_; _≤?_)
open import Function

open import Arithmetic hiding (n)
open import Lists
open import Compact hiding (n; l)
open import SwapLemmas
open import ImpossibleLemmas
open ≤-Reasoning renaming (begin_ to ≤-begin_; _∎ to ≤∎) hiding (_≡⟨⟩_; step-≡)
open _⊎_

open import Relation.Binary
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; subst) renaming (trans to ≡-trans; sym to ≡-sym)


variable
    n : ℕ
    l : List ℕ

open ≅*-Reasoning
open Relation.Binary.PropositionalEquality.≡-Reasoning

open Σ

---------------
--- Pi lang ---
---------------

data Pi-type : Set where
  
data _<->_ : Pi-type -> Pi-type -> Set where
  
data _<=>_ : {A B C D : Pi-type} -> (A <-> B) -> (C <-> D) -> Set where
  
-- TODO and all other stuff from Pi



---------------
--- Stage 1 ---
---------------
PiFin : ℕ -> Pi-type

data Normed1comb : {n : ℕ} -> (PiFin n) <-> (PiFin n) -> Set where
  

Pi-norm  : {A B : Pi-type} -> (c : A <-> B) -> Σ ℕ (λ n -> Σ ((PiFin n) <-> (PiFin n)) (λ cc -> (Normed1comb cc) × (c <=> cc)))

---------------
--- Stage 2 ---
---------------
Pi-sseq : {n : ℕ} -> (c : PiFin n <-> PiFin n) -> List (Fin n)
sseq-Pi : {n : ℕ} -> List (Fin n) -> (PiFin n <-> PiFin n)

Pi-sseq-Pi : {n : ℕ} -> (Pi-sseq {n}) ∘ (sseq-Pi {n}) ≡ id
sseq-Pi-sseq : {n : ℕ} -> (sseq-Pi {n}) ∘ (Pi-sseq {n}) ≡ id

---------------
--- Stage 3 ---
---------------

data _≃_ : {n : ℕ} -> List (Fin n) -> List (Fin n) -> Set where
  

data _≈_ : Set -> Set -> Set where
  bijection : {A B : Set} -> (f : A -> B) -> (g : B -> A) -> (f ∘ g ≡ id) -> (g ∘ f ≡ id) -> (A ≈ B)

data Lehmer : ℕ -> Set where
  LZ : Lehmer 0
  LS : (l : Lehmer n) -> {r : ℕ} -> (r ≤ suc n) -> Lehmer (suc n)

immerse : {n : ℕ} -> Lehmer n -> List (Fin n)
immerse-inj : {n : ℕ} -> (l1 l2 : Lehmer n) -> immerse l1 ≡ immerse l2 -> l1 ≡ l2

sseq-norm : {n : ℕ} -> (l : List (Fin n)) -> Σ (Lehmer n) (λ cl -> l ≃ immerse cl)


---------------
--- Stage 4 ---
---------------

eval  : {n : ℕ} -> (Lehmer n) -> (Fin n ≈ Fin n)
fquote : {n : ℕ} -> (Fin n ≈ Fin n) -> (Lehmer n)

eval∘fquote : {n : ℕ} -> (eval {n}) ∘ (fquote {n}) ≡ id
fquote∘eval : {n : ℕ} -> (fquote {n}) ∘ (eval {n}) ≡ id

---------------
---   All   ---
---------------

Pi-eval : Σ (Pi-type × Pi-type) (λ (A , B) -> (A <-> B)) -> Σ ℕ (λ n -> (Fin n) ≈ (Fin n))
Pi-eval (a , c) =
  let x = proj₁ (proj₂ (Pi-norm c))
      nx = proj₁ (Pi-norm c)
  in  (nx , eval (proj₁ (sseq-norm (Pi-sseq x))))

fquote-Pi : Σ ℕ (λ n -> (Fin n) ≈ (Fin n)) -> Σ (Pi-type × Pi-type) (λ (A , B) -> (A <-> B))
fquote-Pi (n , b) =
  let x = sseq-Pi (immerse (fquote b))
  in  (PiFin n , PiFin n) , x

fquote-eval : Pi-eval ∘ fquote-Pi ≡ id
fquote-eval = ≡-trans {!!} {!fquote∘eval!}

-- eval-fquote : {A B : Pi-type} -> (c : A <-> B) -> ((fquote-Pi ∘ Pi-eval) c) <=> c
