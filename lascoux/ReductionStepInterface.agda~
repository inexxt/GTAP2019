{-# OPTIONS --allow-unsolved-metas #-}

module ReductionStepInterface where

open import Data.List
open import Data.Nat
open import Data.List.Properties
open import Data.Nat.Properties
open import Data.Product using (∃; Σ; _×_; _,_; _,′_)
open import Relation.Binary
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; subst) renaming (trans to ≡-trans; sym to ≡-sym)

open import General
open import Relation.Nullary
open import Data.Empty
open Relation.Binary.PropositionalEquality.≡-Reasoning

open import Coxeter hiding (n; l)
open import Arithmetic hiding (n; l)
open import Canonization hiding (n; l)
open import CanonizationInterface hiding (n; l)
open import ReductionStep using (all-reduce; _>>_)

open _≃_
open ≃-Reasoning
open Σ

variable
  n : ℕ
  l : List ℕ

-- data _>>_ : ℕ -> List ℕ -> Set where
--   [] : {n : ℕ} -> n >> []
--   _:⟨_⟩:_ : {n : ℕ} -> {l : List ℕ} -> (k : ℕ) -> (k < n) -> n >> l -> n >> (k ∷ l)

-- all-reduce : {w : List ℕ}
--            -> {w' : List ℕ}
--            -> {n : ℕ}
--            -> (zero < n)
--            -> {r : ℕ}
--            -> (r ≤ (suc n))
--            -> (ww : n >> w)
--            -> (ww' : (suc n) >> w')
--            -> Σ ((List ℕ) × ℕ) (λ (w'' , r') -> (n >> w'') × (w'' ++ ((suc n) ↓ r')) ≃ (w ++ ((suc n) ↓ r) ++ w'))

step : (ll : (suc n) >> l) -> Σ (List ℕ × ℕ) (λ (l' , r) -> (n >> l') × (l' ++ ((suc (suc n)) ↓ r)) ≃ l)
-- step {n} {.[]} [] = ([] , 0) , ([] , refl)
-- step {n} {k ∷ l} (.k :⟨ x ⟩: ll) with (suc k) ≟ (suc n)
-- ... | yes p =
--   let xx = all-reduce {!!}  {!!} {!!} {!!} {!!} {!!}
--   in  {!!}
-- ... | no p =
--   let k≤n : k < n
--       k≤n = ≤-≠-≤ x p
--       (l' , r) , (ll' , pp) = step ll
--   in ((k ∷ l') , r) , ((k :⟨ k≤n ⟩: ll') , (prepend k pp))


data Canonical : (n : ℕ) -> Set where
  CanZ : Canonical 0
  CanS : {n : ℕ} -> (k r : ℕ) -> (n < k) -> (r ≤ k) -> (l : Canonical n) -> Canonical k

immersion : {n : ℕ} -> Canonical n -> List ℕ
immersion {zero} CanZ = []
immersion {suc n} (CanS k r n<k r≤k l) = (k ↓ r) ++ immersion l

open import Data.Fin

canonical-form-lemma : {n : ℕ} -> (l : List (Fin n)) -> ∃ (λ cl -> (map (λ x -> toℕ x) l) ≃ (immersion {n} cl))

canonical-form-lemma-Free : (l : List ℕ) -> ∃ (λ n -> ∃ (λ cl -> l ≃ (immersion {n} cl)))
