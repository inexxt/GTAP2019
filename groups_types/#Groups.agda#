{-# OPTIONS --cubical --without-K #-}

module Groups where
    open import Cubical.Core.Everything using (Level ; _,_ ; _â‰¡_ ; symP)
    open import Cubical.Foundations.Id using (isContr ; fiber ; compPath ; isEquiv ; _â‰ƒ_)

    variable
        â„“ : Level

    refl : {A : Set} -> {x : A} -> x â‰¡ x
    refl {x = x} = {!!}

    data S3 : Set where
        * : S3
        e1 : * â‰¡ *
        e2 : * â‰¡ *
        b1 : compPath e2 (compPath e1 e2) â‰¡ compPath e1 (compPath e2 e1)
        i1 : compPath e1 e1 â‰¡ refl
        i2 : compPath e2 e2 â‰¡ refl

    data F3 : Set where
        a1 : F3
        a2 : F3
        a3 : F3

    absurd : {A : Set} -> a1 â‰¡ a2 -> A
    absurd p = {!   !}

    proj1â‰¡ : {A : Set} -> {B : A -> Set} -> {a1 a2 : A} -> {b1 : B a1} -> {b2 : B a2} -> (a1 , b1) â‰¡ (a2 , b2) -> (a1 â‰¡ a2)
    proj1â‰¡ p = {!!}

    p : (f : F3 -> F3) -> isEquiv f -> * â‰¡ *
    p f e with f a1 , f a2 , f a3
    p f record { equiv-proof = equiv-proof } | a1 , a1 , _  = let a , b = equiv-proof a1
                                                                  t1 = b (a1 , _)
                                                                  t2 = b (a2 , _)
                                                                  abs = compPath (symP t1) t2 in
                                                              absurd (proj1â‰¡ abs)
    p f record { equiv-proof = equiv-proof } | _  , a1 , a1 = {!   !}
    p f record { equiv-proof = equiv-proof } | a1 , _  , a1 = {!   !}
    p f record { equiv-proof = equiv-proof } | a2 , a2 , _  = {!  !}
    p f record { equiv-proof = equiv-proof } | _  , a2 , a2 = {!   !}
    p f record { equiv-proof = equiv-proof } | a2 , _  , a2 = {!   !}
    p f record { equiv-proof = equiv-proof } | a3 , a3 , _  = {!  !}
    p f record { equiv-proof = equiv-proof } | _  , a3 , a3 = {!   !}
    p f record { equiv-proof = equiv-proof } | a3 , _  , a3 = {!   !}
    ... | a1 , a2 , a3 = refl
    ... | a1 , a3 , a2 =  e2
    ... | a2 , a1 , a3 =  e1
    ... | a2 , a3 , a1 =  compPath  e1 e2
    ... | a3 , a1 , a2 =  compPath e2 e1
    ... | a3 , a2 , a1 =  compPath (compPath e1 e2) e1

    proof : (F3 â‰ƒ F3) â‰ƒ (* â‰¡ *)
    proof = (Î» { (f , e) â†’ p f e}) , record { equiv-proof = {!eqv!} }

    eqv : (y : * â‰¡ *) -> isContr (fiber (Î» { (f , e) â†’ p f e }))

    -- data Sn {n : â„•}: Set where
    --     Per : ((k : Fin n) -> (Fin (suc (toâ„• k)))) -> Sn

    -- ğŸ› : Set
    -- ğŸ› = Sn {3}

    -- -- x is a (12) cycle
    -- x : ğŸ›
    -- x = Per (Î» { zero â†’ # 0 ;
    --             (suc zero) â†’  # 0 ;
    --             (suc (suc zero)) â†’  # 2  })
